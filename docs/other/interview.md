# 重在属性展示

高能量，体力多，变化

## :star: 原型与原型链

::: details

```md
原型是？每个JS对象（除null外）都有一个内置的[[Prototype]] 属性，这个属性就是对象的原型。
通过原型，对象可以共享属性和方法。

原型链是JavaScript实现继承的机制。当访问对象属性时，如果对象本身没有该属性，
JavaScript引擎会查找对象的原型[[Prototype]],如果原型上也没有，就继续查找
原型的原型，直到找到该属性 或到达原型链末端（null）

__proto__和prototype的区别？
prototype是函数特有的属性，__proto__是每个对象（除null外）都有的属性。
它们之间存在这样的关系，
对象的原型__proto__会永远指向它的构造函数的属性prototype。

Object.prototype.constructor === Object; // true
构造函数的属性prototype可以通过constructor指向构造函数。
```

:::

## :star: 闭包

::: details

```md
闭包是？函数和声明该函数的词法环境的组合。

闭包的特性：
创建私有变量（保护变量不被外部修改）
延长变量的生命周期：正常情况下函数执行完后，其内部变量会被销毁，但闭包可以使这些
变量继续存在于内存中。

闭包的形成条件：
函数嵌套
内部函数引用了外部函数的变量
内部函数在外部函数之外被调用

应用：防抖，节流，函数柯里化，延时执行（事件处理、异步回调，eg:setTimeout）

闭包会引起内存泄漏？
闭包不会引起内存泄漏。
从语言设计层面看。
闭包的行为是 JavaScript 的 语言特性，符合 ECMAScript 规范，不是缺陷。
从内存管理看？
闭包引用的变量，只要闭包函数本身还被引用，就不会被GC回收。
当闭包函数不再引用时，闭包和它引用的变量，就会被正常回收。
而内存泄漏的真正原因：通常是 程序逻辑错误，比如：
未清除的 setInterval / setTimeout
未解绑的 DOM 事件监听
意外的全局变量引用

var i = 0;          // 全局变量
function foo() {    // 普通函数（不是嵌套函数）
    console.log(i); // 访问全局变量
}
foo();             // 直接调用
```

:::

## :star: 事件循环

::: details

```md
事件循环是JavaScript为了实现非阻塞的异步执行而设计的一套机制

首先js是单线程的，意味着它一次只能做一件事。
如果在浏览器中执行一个耗时很长的同步任务，页面响应就会显得很慢，
进而影响用户体验。为了不阻塞主线程，继续执行其他任务，
JS将这些耗时操作交给浏览器环境提供的
其他线程去处理。等这些耗时操作有了结果，再通知JS主线程
来执行对应的回调函数。这个“通知”和“调度”的机制，就是事件循环。

事件循环的周期是这样的？
将所有的同步代码依次压入调用栈执行，
如果遇到异步API，
如setTimeout，交给Web APIs计时线程处理，计时结束后其回调被放入宏任务队列。
如Promise.resolve().then(...)，.then()，会将其回调被放入微任务队列。
待同步代码执行完毕，调用栈为空。
事件循环优先检查微任务队列，将里面所有的微任务依次取出并执行完毕，
直到微任务队列清空，
浏览器才进行UI渲染。
事件循环此时才检查宏任务队列：取出宏任务队列中的第一个回调函数，压入调用栈执行
如果在这个宏任务执行期间，又可能产生新的同步代码、微任务、宏任务。继续如上操作。

宏任务
setTimeout, setInterval, setImmediate (Node), I/O操作, UI渲染, 
事件回调（如click）
微任务
Promise.then(), Promise.catch(), Promise.finally(), 
process.nextTick() (Node, 优先级最高), MutationObserver。
```

:::